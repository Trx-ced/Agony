local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer

local TitansFolder = workspace:WaitForChild("MainFolders"):WaitForChild("Titans")
local TemplateRig = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Titan"):WaitForChild("Rig")

local State = {
	NapeEnabled = false,
	NapeMult = 5,
	DisableGrabHitboxes = false,
	TitanESP = false,
	TitanESPBoxTransparency = 1
}

local COLLISION_HITBOX_NAMES = {
	LeftFootCollision = true,
	LeftHandCollision = true,
	LeftLowerArmCollision = true,
	LeftLowerLegCollision = true,
	LeftUpperArmCollision = true,
	LeftUpperLegCollision = true,

	RightFootCollision = true,
	RightHandCollision = true,
	RightLowerArmCollision = true,
	RightLowerLegCollision = true,
	RightUpperArmCollision = true,
	RightUpperLegCollision = true,
	Head = true,
	Jaw = true, 
}

local LIMB_NAMES = {
	LeftHand = true,
	LeftLowerArm = true,
	LeftUpperArm = true,
	LeftFoot = true,
	LeftLowerLeg = true,
	LeftUpperLeg = true,

	RightHand = true,
	RightLowerArm = true,
	RightUpperArm = true,
	RightFoot = true,
	RightLowerLeg = true,
	RightUpperLeg = true,

	Head = true,
	Jaw = true,
}

local EXTRA_COLLIDER_NAMES = {
	HeadCollision = true,
}

local function storeBasePartState(part)
	if part:GetAttribute("HB_Stored") then return end
	part:SetAttribute("HB_Stored", true)

	part:SetAttribute("HB_OrigSizeX", part.Size.X)
	part:SetAttribute("HB_OrigSizeY", part.Size.Y)
	part:SetAttribute("HB_OrigSizeZ", part.Size.Z)

	part:SetAttribute("HB_OrigCanCollide", part.CanCollide and 1 or 0)
	part:SetAttribute("HB_OrigCanTouch", part.CanTouch and 1 or 0)
	part:SetAttribute("HB_OrigCanQuery", part.CanQuery and 1 or 0)
	part:SetAttribute("HB_OrigMassless", part.Massless and 1 or 0)

	local mesh = part:FindFirstChildWhichIsA("SpecialMesh")
	if mesh then
		part:SetAttribute("HB_HasMesh", 1)
		part:SetAttribute("HB_OrigMeshX", mesh.Scale.X)
		part:SetAttribute("HB_OrigMeshY", mesh.Scale.Y)
		part:SetAttribute("HB_OrigMeshZ", mesh.Scale.Z)
	else
		part:SetAttribute("HB_HasMesh", 0)
	end
end

local function restoreBasePartState(part)
	if not part:GetAttribute("HB_Stored") then return end

	local sx = part:GetAttribute("HB_OrigSizeX")
	local sy = part:GetAttribute("HB_OrigSizeY")
	local sz = part:GetAttribute("HB_OrigSizeZ")
	if sx and sy and sz then
		part.Size = Vector3.new(sx, sy, sz)
	end

	part.CanCollide = (part:GetAttribute("HB_OrigCanCollide") == 1)
	part.CanTouch = (part:GetAttribute("HB_OrigCanTouch") == 1)
	part.CanQuery = (part:GetAttribute("HB_OrigCanQuery") == 1)
	part.Massless = (part:GetAttribute("HB_OrigMassless") == 1)

	if part:GetAttribute("HB_HasMesh") == 1 then
		local mesh = part:FindFirstChildWhichIsA("SpecialMesh")
		if mesh then
			local mx = part:GetAttribute("HB_OrigMeshX")
			local my = part:GetAttribute("HB_OrigMeshY")
			local mz = part:GetAttribute("HB_OrigMeshZ")
			if mx and my and mz then
				mesh.Scale = Vector3.new(mx, my, mz)
			end
		end
	end
end

local function findNape(root)
	for _, d in ipairs(root:GetDescendants()) do
		if d:IsA("BasePart") and d.Name == "Nape" then
			return d
		end
	end
	return nil
end

local function applyNapeToRig(rig)
	if not (rig and rig:IsA("Model")) then return end
	local nape = findNape(rig)
	if not nape then return end

	storeBasePartState(nape)

	if State.NapeEnabled then
		nape.CanCollide = false
		nape.CanTouch = true
		nape.CanQuery = true
		nape.Massless = true
		nape.Anchored = false

		local ox = nape:GetAttribute("HB_OrigSizeX")
		local oy = nape:GetAttribute("HB_OrigSizeY")
		local oz = nape:GetAttribute("HB_OrigSizeZ")
		if ox and oy and oz then
			nape.Size = Vector3.new(ox, oy, oz) * State.NapeMult
		end
	else
		restoreBasePartState(nape)
	end
end

local function disableBasePart(part)
	if part.Name == "Nape" then return end
	storeBasePartState(part)
	part.CanTouch = false
	part.CanQuery = false
	part.CanCollide = false
	part.Massless = true
end

local function disableAny(inst)
	if inst:IsA("BasePart") then
		disableBasePart(inst)
		return
	end
	for _, d in ipairs(inst:GetDescendants()) do
		if d:IsA("BasePart") then
			disableBasePart(d)
		end
	end
end

local function applyDisableGrabHitboxesToRig(rig)
	if not (rig and rig:IsA("Model")) then return end

	if not State.DisableGrabHitboxes then
		for _, d in ipairs(rig:GetDescendants()) do
			if d:IsA("BasePart") and d.Name ~= "Nape" then
				restoreBasePartState(d)
			end
		end
		return
	end

	local collisionsFolder = rig:FindFirstChild("Collisions")
	if collisionsFolder then
		for _, d in ipairs(collisionsFolder:GetDescendants()) do
			if COLLISION_HITBOX_NAMES[d.Name] then
				disableAny(d)
			end
		end
	end

	for _, d in ipairs(rig:GetDescendants()) do
		if LIMB_NAMES[d.Name] then
			disableAny(d)
		end
	end

	local head = rig:FindFirstChild("Head", true)
	if head then
		for _, d in ipairs(head:GetDescendants()) do
			if EXTRA_COLLIDER_NAMES[d.Name] then
				disableAny(d)
			end
		end
	end
end

local function patchRig(rig)
	applyNapeToRig(rig)
	applyDisableGrabHitboxesToRig(rig)
end

local function patchAll()
	patchRig(TemplateRig)
	for _, rig in ipairs(TitansFolder:GetChildren()) do
		patchRig(rig)
	end
end

patchAll()

TitansFolder.ChildAdded:Connect(function(rig)
	task.wait(0.15)
	patchRig(rig)
	task.delay(0.75, function()
		patchRig(rig)
	end)
end)

local debugByNape = {}

local function getRoot()
	local char = player.Character
	if not char then return nil end
	return char:FindFirstChild("HumanoidRootPart")
end

local function getTitanType(rig)
	local attr = rig:GetAttribute("TitanType")
	if typeof(attr) == "string" and attr ~= "" then
		return attr
	end
	return rig.Name
end

local function makeBox(nape)
	local box = Instance.new("SelectionBox")
	box.Name = "TitanESP_Box"
	box.Adornee = nape
	box.LineThickness = 0.05
	box.Color3 = Color3.fromRGB(255, 0, 0)
	local t = math.clamp(State.TitanESPBoxTransparency, 0, 1)
	box.Transparency = t
	box.SurfaceTransparency = t
	box.Parent = nape
	return box
end

local function makeText(nape)
	local bb = Instance.new("BillboardGui")
	bb.Name = "TitanESP_Info"
	bb.Adornee = nape
	bb.AlwaysOnTop = true
	bb.Size = UDim2.fromOffset(220, 36)
	bb.StudsOffset = Vector3.new(0, 3.1, 0)

	local label = Instance.new("TextLabel")
	label.Name = "Info"
	label.Size = UDim2.fromScale(1, 1)
	label.BackgroundTransparency = 1
	label.TextColor3 = Color3.fromRGB(255, 255, 255)
	label.TextStrokeTransparency = 0.35
	label.Font = Enum.Font.GothamBold
	label.TextSize = 16
	label.TextXAlignment = Enum.TextXAlignment.Center
	label.TextYAlignment = Enum.TextYAlignment.Center
	label.Text = ""
	label.Parent = bb

	bb.Parent = nape
	return bb, label
end

local function espAttach(rig)
	if not rig:IsA("Model") then return end
	local nape = findNape(rig)
	if not nape then return end
	if debugByNape[nape] then return end

	local box = makeBox(nape)
	local bb, label = makeText(nape)
	debugByNape[nape] = { box = box, bb = bb, label = label, rig = rig }

	nape.AncestryChanged:Connect(function(_, parent)
		if parent == nil then
			local info = debugByNape[nape]
			if info then
				if info.box then info.box:Destroy() end
				if info.bb then info.bb:Destroy() end
			end
			debugByNape[nape] = nil
		end
	end)
end

local function espDetachAll()
	for nape, info in pairs(debugByNape) do
		if info.box then info.box:Destroy() end
		if info.bb then info.bb:Destroy() end
		debugByNape[nape] = nil
	end
end

local function espApplyTransparency()
	local t = math.clamp(State.TitanESPBoxTransparency, 0, 1)
	for _, info in pairs(debugByNape) do
		if info and info.box then
			info.box.Transparency = t
			info.box.SurfaceTransparency = t
		end
	end
end

for _, rig in ipairs(TitansFolder:GetChildren()) do
	espAttach(rig)
end

TitansFolder.ChildAdded:Connect(function(rig)
	task.wait(0.15)
	if State.TitanESP then
		espAttach(rig)
	end
	task.delay(0.75, function()
		if State.TitanESP then
			espAttach(rig)
		end
	end)
end)

RunService.RenderStepped:Connect(function()
	if not State.TitanESP then return end
	local hrp = getRoot()
	if not hrp then return end
	for nape, info in pairs(debugByNape) do
		if not (nape and nape.Parent and info and info.label and info.rig) then
			debugByNape[nape] = nil
		else
			local dist = (hrp.Position - nape.Position).Magnitude
			local ttype = getTitanType(info.rig)
			info.label.Text = string.format("%s  |  %.1f studs", ttype, dist)
		end
	end
end)

local function mk(t, props)
	local inst = Instance.new(t)
	for k, v in pairs(props or {}) do
		inst[k] = v
	end
	return inst
end

local COL_BG = Color3.fromRGB(16,16,16)
local COL_PANEL = Color3.fromRGB(22,22,22)
local COL_PANEL2 = Color3.fromRGB(28,28,28)
local COL_STROKE = Color3.fromRGB(55,55,55)
local COL_TEXT = Color3.fromRGB(235,235,235)
local COL_SUB = Color3.fromRGB(160,160,160)
local COL_PURP = Color3.fromRGB(140, 90, 255)
local COL_OFF = Color3.fromRGB(120, 55, 55)
local COL_ON = Color3.fromRGB(60, 160, 90)

local gui = mk("ScreenGui", {
	Name = "CheddarcheeseHub",
	ResetOnSpawn = false,
	Parent = player:WaitForChild("PlayerGui"),
})

local main = mk("Frame", {
	Parent = gui,
	Position = UDim2.new(0.15, 0, 0.2, 0),
	Size = UDim2.new(0, 700, 0, 380),
	BackgroundColor3 = COL_BG,
	BorderSizePixel = 0,
})
mk("UICorner", { Parent = main, CornerRadius = UDim.new(0, 8) })
mk("UIStroke", { Parent = main, Color = COL_STROKE, Thickness = 1, Transparency = 0.35 })

local top = mk("Frame", {
	Parent = main,
	Size = UDim2.new(1, 0, 0, 34),
	BackgroundColor3 = COL_BG,
	BorderSizePixel = 0,
})
mk("UIStroke", { Parent = top, Color = COL_STROKE, Thickness = 1, Transparency = 0.5 })

mk("TextLabel", {
	Parent = top,
	Position = UDim2.new(0, 12, 0, 0),
	Size = UDim2.new(1, -160, 1, 0),
	BackgroundTransparency = 1,
	Font = Enum.Font.GothamBold,
	TextSize = 14,
	TextXAlignment = Enum.TextXAlignment.Left,
	TextColor3 = COL_TEXT,
	Text = "Cheddarcheese Hub",
})

mk("TextLabel", {
	Parent = top,
	AnchorPoint = Vector2.new(1, 0.5),
	Position = UDim2.new(1, -46, 0.5, 0),
	Size = UDim2.new(0, 200, 1, 0),
	BackgroundTransparency = 1,
	Font = Enum.Font.Gotham,
	TextSize = 11,
	TextXAlignment = Enum.TextXAlignment.Right,
	TextColor3 = COL_SUB,
	Text = "RightShift to toggle UI",
})

local minimizeBtn = mk("TextButton", {
	Parent = top,
	AnchorPoint = Vector2.new(1, 0.5),
	Position = UDim2.new(1, -10, 0.5, 0),
	Size = UDim2.new(0, 26, 0, 22),
	BackgroundColor3 = COL_PANEL,
	TextColor3 = COL_TEXT,
	BorderSizePixel = 0,
	Font = Enum.Font.GothamBold,
	TextSize = 14,
	Text = "–",
	AutoButtonColor = false,
})
mk("UICorner", { Parent = minimizeBtn, CornerRadius = UDim.new(0, 6) })
mk("UIStroke", { Parent = minimizeBtn, Color = COL_STROKE, Thickness = 1, Transparency = 0.4 })

local side = mk("Frame", {
	Parent = main,
	Position = UDim2.new(0, 0, 0, 34),
	Size = UDim2.new(0, 160, 1, -34),
	BackgroundColor3 = COL_PANEL,
	BorderSizePixel = 0,
})
mk("UIStroke", { Parent = side, Color = COL_STROKE, Thickness = 1, Transparency = 0.55 })

local content = mk("Frame", {
	Parent = main,
	Position = UDim2.new(0, 160, 0, 34),
	Size = UDim2.new(1, -160, 1, -34),
	BackgroundColor3 = COL_BG,
	BorderSizePixel = 0,
})

local pages = {}

local function newPage(name)
	local f = mk("Frame", {
		Parent = content,
		Size = UDim2.new(1, 0, 1, 0),
		BackgroundTransparency = 1,
		Visible = false,
	})
	pages[name] = f
	return f
end

local pageMain = newPage("Main")
local pageVisuals = newPage("Visuals")
local pageUI = newPage("UI Settings")

local function sectionBox(parent, x, y, w, h, headerText)
	local box = mk("Frame", {
		Parent = parent,
		Position = UDim2.new(0, x, 0, y),
		Size = UDim2.new(0, w, 0, h),
		BackgroundColor3 = COL_PANEL,
		BorderSizePixel = 0,
	})
	mk("UICorner", { Parent = box, CornerRadius = UDim.new(0, 10) })
	mk("UIStroke", { Parent = box, Color = COL_STROKE, Thickness = 1, Transparency = 0.5 })

	mk("TextLabel", {
		Parent = box,
		Position = UDim2.new(0, 12, 0, 10),
		Size = UDim2.new(1, -24, 0, 18),
		BackgroundTransparency = 1,
		Font = Enum.Font.GothamBold,
		TextSize = 13,
		TextXAlignment = Enum.TextXAlignment.Left,
		TextColor3 = COL_TEXT,
		Text = headerText,
	})

	return box
end

local function toggleRow(parent, y, labelText)
	mk("TextLabel", {
		Parent = parent,
		Position = UDim2.new(0, 12, 0, y),
		Size = UDim2.new(1, -80, 0, 20),
		BackgroundTransparency = 1,
		Font = Enum.Font.Gotham,
		TextSize = 12,
		TextXAlignment = Enum.TextXAlignment.Left,
		TextColor3 = COL_SUB,
		Text = labelText,
	})

	local btn = mk("TextButton", {
		Parent = parent,
		AnchorPoint = Vector2.new(1, 0),
		Position = UDim2.new(1, -12, 0, y-2),
		Size = UDim2.new(0, 52, 0, 22),
		BackgroundColor3 = COL_ON,
		TextColor3 = COL_TEXT,
		BorderSizePixel = 0,
		Font = Enum.Font.GothamBold,
		TextSize = 12,
		Text = "ON",
		AutoButtonColor = false,
	})
	mk("UICorner", { Parent = btn, CornerRadius = UDim.new(0, 10) })
	mk("UIStroke", { Parent = btn, Color = COL_STROKE, Thickness = 1, Transparency = 0.5 })

	return btn
end

local function setToggle(btn, on)
	btn.Text = on and "ON" or "OFF"
	btn.BackgroundColor3 = on and COL_ON or COL_OFF
end

local boxA = sectionBox(pageMain, 16, 16, 420, 320, "Titan Settings")
local napeToggle = toggleRow(boxA, 44, "Nape Hitbox")
local grabHBtoggle = toggleRow(boxA, 78, "Disable Grab Hitboxes")

mk("TextLabel", {
	Parent = boxA,
	Position = UDim2.new(0, 12, 0, 120),
	Size = UDim2.new(1, -24, 0, 18),
	BackgroundTransparency = 1,
	Font = Enum.Font.Gotham,
	TextSize = 12,
	TextXAlignment = Enum.TextXAlignment.Left,
	TextColor3 = COL_SUB,
	Text = "Nape Multiplier (1-30)",
})

local multBox = mk("TextBox", {
	Parent = boxA,
	Position = UDim2.new(0, 12, 0, 142),
	Size = UDim2.new(0, 280, 0, 26),
	BackgroundColor3 = Color3.fromRGB(26,26,26),
	TextColor3 = COL_TEXT,
	BorderSizePixel = 0,
	ClearTextOnFocus = false,
	Font = Enum.Font.GothamSemibold,
	TextSize = 12,
	Text = tostring(State.NapeMult),
})
mk("UICorner", { Parent = multBox, CornerRadius = UDim.new(0, 8) })
mk("UIStroke", { Parent = multBox, Color = COL_STROKE, Thickness = 1, Transparency = 0.55 })

local applyBtn = mk("TextButton", {
	Parent = boxA,
	Position = UDim2.new(0, 302, 0, 142),
	Size = UDim2.new(0, 106, 0, 26),
	BackgroundColor3 = COL_PURP,
	TextColor3 = COL_TEXT,
	BorderSizePixel = 0,
	Font = Enum.Font.GothamBold,
	TextSize = 12,
	Text = "APPLY",
	AutoButtonColor = false,
})
mk("UICorner", { Parent = applyBtn, CornerRadius = UDim.new(0, 8) })

local boxV = sectionBox(pageVisuals, 16, 16, 420, 320, "Visuals")
local espToggle = toggleRow(boxV, 44, "Titan ESP (Nape)")

mk("TextLabel", {
	Parent = boxV,
	Position = UDim2.new(0, 12, 0, 88),
	Size = UDim2.new(1, -24, 0, 18),
	BackgroundTransparency = 1,
	Font = Enum.Font.Gotham,
	TextSize = 12,
	TextXAlignment = Enum.TextXAlignment.Left,
	TextColor3 = COL_SUB,
	Text = "ESP Box Transparency (0-1)",
})

local espTransBox = mk("TextBox", {
	Parent = boxV,
	Position = UDim2.new(0, 12, 0, 110),
	Size = UDim2.new(0, 280, 0, 26),
	BackgroundColor3 = Color3.fromRGB(26,26,26),
	TextColor3 = COL_TEXT,
	BorderSizePixel = 0,
	ClearTextOnFocus = false,
	Font = Enum.Font.GothamSemibold,
	TextSize = 12,
	Text = tostring(State.TitanESPBoxTransparency),
})
mk("UICorner", { Parent = espTransBox, CornerRadius = UDim.new(0, 8) })
mk("UIStroke", { Parent = espTransBox, Color = COL_STROKE, Thickness = 1, Transparency = 0.55 })

local espApplyBtn = mk("TextButton", {
	Parent = boxV,
	Position = UDim2.new(0, 302, 0, 110),
	Size = UDim2.new(0, 106, 0, 26),
	BackgroundColor3 = COL_PURP,
	TextColor3 = COL_TEXT,
	BorderSizePixel = 0,
	Font = Enum.Font.GothamBold,
	TextSize = 12,
	Text = "APPLY",
	AutoButtonColor = false,
})
mk("UICorner", { Parent = espApplyBtn, CornerRadius = UDim.new(0, 8) })

local boxU = sectionBox(pageUI, 16, 16, 420, 320, "UI Settings")
mk("TextLabel", {
	Parent = boxU,
	Position = UDim2.new(0, 12, 0, 44),
	Size = UDim2.new(1, -24, 0, 18),
	BackgroundTransparency = 1,
	Font = Enum.Font.Gotham,
	TextSize = 12,
	TextXAlignment = Enum.TextXAlignment.Left,
	TextColor3 = COL_SUB,
	Text = "Toggle Keybind: RightShift",
})

local resetPos = mk("TextButton", {
	Parent = boxU,
	Position = UDim2.new(0, 12, 0, 74),
	Size = UDim2.new(0, 180, 0, 26),
	BackgroundColor3 = COL_PURP,
	TextColor3 = COL_TEXT,
	BorderSizePixel = 0,
	Font = Enum.Font.GothamBold,
	TextSize = 12,
	Text = "Reset UI Position",
	AutoButtonColor = false,
})
mk("UICorner", { Parent = resetPos, CornerRadius = UDim.new(0, 8) })

local tabButtons = {}

local function setTabActive(name)
	for tabName, frame in pairs(pages) do
		frame.Visible = (tabName == name)
	end
	for tabName, btn in pairs(tabButtons) do
		local on = (tabName == name)
		btn.BackgroundColor3 = on and COL_PANEL2 or COL_PANEL
		btn.TextColor3 = on and COL_TEXT or COL_SUB
	end
end

local function makeSideTab(y, text, name)
	local tab = mk("TextButton", {
		Parent = side,
		Position = UDim2.new(0, 10, 0, y),
		Size = UDim2.new(1, -20, 0, 36),
		BackgroundColor3 = COL_PANEL,
		TextColor3 = COL_SUB,
		BorderSizePixel = 0,
		Font = Enum.Font.GothamSemibold,
		TextSize = 13,
		TextXAlignment = Enum.TextXAlignment.Left,
		Text = "   "..text,
		AutoButtonColor = false,
	})
	mk("UICorner", { Parent = tab, CornerRadius = UDim.new(0, 10) })
	tabButtons[name] = tab
	tab.MouseButton1Click:Connect(function()
		setTabActive(name)
	end)
	return tab
end

makeSideTab(12, "Main", "Main")
makeSideTab(56, "Visuals", "Visuals")
makeSideTab(100, "UI Settings", "UI Settings")

local function applyMultiplier()
	local n = tonumber(multBox.Text)
	if not n then
		multBox.Text = tostring(State.NapeMult)
		return
	end
	n = math.floor(n + 0.5)
	n = math.clamp(n, 1, 30)
	State.NapeMult = n
	patchAll()
end

local function applyESPTrans()
	local n = tonumber(espTransBox.Text)
	if not n then
		espTransBox.Text = tostring(State.TitanESPBoxTransparency)
		return
	end
	n = math.clamp(n, 0, 1)
	State.TitanESPBoxTransparency = n
	espTransBox.Text = tostring(State.TitanESPBoxTransparency)
	espApplyTransparency()
end

local function refresh()
	setToggle(napeToggle, State.NapeEnabled)
	setToggle(grabHBtoggle, State.DisableGrabHitboxes)
	setToggle(espToggle, State.TitanESP)
	multBox.Text = tostring(State.NapeMult)
	espTransBox.Text = tostring(State.TitanESPBoxTransparency)
	if not State.TitanESP then
		espDetachAll()
	end
end

napeToggle.MouseButton1Click:Connect(function()
	State.NapeEnabled = not State.NapeEnabled
	patchAll()
	refresh()
end)

grabHBtoggle.MouseButton1Click:Connect(function()
	State.DisableGrabHitboxes = not State.DisableGrabHitboxes
	patchAll()
	refresh()
end)

espToggle.MouseButton1Click:Connect(function()
	State.TitanESP = not State.TitanESP
	if State.TitanESP then
		for _, rig in ipairs(TitansFolder:GetChildren()) do
			espAttach(rig)
		end
		espApplyTransparency()
	else
		espDetachAll()
	end
	refresh()
end)

applyBtn.MouseButton1Click:Connect(function()
	applyMultiplier()
	refresh()
end)

multBox.FocusLost:Connect(function()
	applyMultiplier()
	refresh()
end)

espApplyBtn.MouseButton1Click:Connect(function()
	applyESPTrans()
	refresh()
end)

espTransBox.FocusLost:Connect(function()
	applyESPTrans()
	refresh()
end)

resetPos.MouseButton1Click:Connect(function()
	main.Position = UDim2.new(0.15, 0, 0.2, 0)
end)

do
	local dragging = false
	local dragStart, startPos
	local top = top
	top.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = true
			dragStart = input.Position
			startPos = main.Position
		end
	end)
	UserInputService.InputChanged:Connect(function(input)
		if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
			local delta = input.Position - dragStart
			main.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
		end
	end)
	UserInputService.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = false
		end
	end)
end

local minimized = false
local fullSize = main.Size
minimizeBtn.MouseButton1Click:Connect(function()
	minimized = not minimized
	content.Visible = not minimized
	side.Visible = not minimized
	main.Size = minimized and UDim2.new(fullSize.X.Scale, fullSize.X.Offset, 0, 34) or fullSize
	minimizeBtn.Text = minimized and "+" or "–"
end)

UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.KeyCode == Enum.KeyCode.RightShift then
		gui.Enabled = not gui.Enabled
	end
end)

setTabActive("Main")
refresh()
