local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer

local TitansFolder = workspace:WaitForChild("MainFolders"):WaitForChild("Titans")
local TemplateRig = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Titan"):WaitForChild("Rig")

local State = {
	NapeEnabled = false,
	NapeMult = 5,
	DisableGrabHitboxes = false,
	TitanESP = false,
	TitanESPBoxTransparency = 1,
	SafeFallEnabled = false,
	MinFallTime = 0.5,
	NearGroundDist = 15,
	SafeFallKey = Enum.KeyCode.L
}

local Connections = {}
local function track(conn)
	table.insert(Connections, conn)
	return conn
end

local unloaded = false
local function safeDisconnectAll()
	for _, c in ipairs(Connections) do
		pcall(function()
			c:Disconnect()
		end)
	end
	table.clear(Connections)
end

local COLLISION_HITBOX_NAMES = {
	LeftFootCollision = true,
	LeftHandCollision = true,
	LeftLowerArmCollision = true,
	LeftLowerLegCollision = true,
	LeftUpperArmCollision = true,
	LeftUpperLegCollision = true,

	RightFootCollision = true,
	RightHandCollision = true,
	RightLowerArmCollision = true,
	RightLowerLegCollision = true,
	RightUpperArmCollision = true,
	RightUpperLegCollision = true,

	Head = true,
	Jaw = true,
}

local LIMB_NAMES = {
	LeftHand = true,
	LeftLowerArm = true,
	LeftUpperArm = true,
	LeftFoot = true,
	LeftLowerLeg = true,
	LeftUpperLeg = true,

	RightHand = true,
	RightLowerArm = true,
	RightUpperArm = true,
	RightFoot = true,
	RightLowerLeg = true,
	RightUpperLeg = true,

	Head = true,
	Jaw = true,
}

local EXTRA_COLLIDER_NAMES = {
	HeadCollision = true,
}

local function storeBasePartState(part)
	if part:GetAttribute("HB_Stored") then return end
	part:SetAttribute("HB_Stored", true)

	part:SetAttribute("HB_OrigSizeX", part.Size.X)
	part:SetAttribute("HB_OrigSizeY", part.Size.Y)
	part:SetAttribute("HB_OrigSizeZ", part.Size.Z)

	part:SetAttribute("HB_OrigCanCollide", part.CanCollide and 1 or 0)
	part:SetAttribute("HB_OrigCanTouch", part.CanTouch and 1 or 0)
	part:SetAttribute("HB_OrigCanQuery", part.CanQuery and 1 or 0)
	part:SetAttribute("HB_OrigMassless", part.Massless and 1 or 0)

	local mesh = part:FindFirstChildWhichIsA("SpecialMesh")
	if mesh then
		part:SetAttribute("HB_HasMesh", 1)
		part:SetAttribute("HB_OrigMeshX", mesh.Scale.X)
		part:SetAttribute("HB_OrigMeshY", mesh.Scale.Y)
		part:SetAttribute("HB_OrigMeshZ", mesh.Scale.Z)
	else
		part:SetAttribute("HB_HasMesh", 0)
	end
end

local function restoreBasePartState(part)
	if not part:GetAttribute("HB_Stored") then return end

	local sx = part:GetAttribute("HB_OrigSizeX")
	local sy = part:GetAttribute("HB_OrigSizeY")
	local sz = part:GetAttribute("HB_OrigSizeZ")
	if sx and sy and sz then
		part.Size = Vector3.new(sx, sy, sz)
	end

	part.CanCollide = (part:GetAttribute("HB_OrigCanCollide") == 1)
	part.CanTouch = (part:GetAttribute("HB_OrigCanTouch") == 1)
	part.CanQuery = (part:GetAttribute("HB_OrigCanQuery") == 1)
	part.Massless = (part:GetAttribute("HB_OrigMassless") == 1)

	if part:GetAttribute("HB_HasMesh") == 1 then
		local mesh = part:FindFirstChildWhichIsA("SpecialMesh")
		if mesh then
			local mx = part:GetAttribute("HB_OrigMeshX")
			local my = part:GetAttribute("HB_OrigMeshY")
			local mz = part:GetAttribute("HB_OrigMeshZ")
			if mx and my and mz then
				mesh.Scale = Vector3.new(mx, my, mz)
			end
		end
	end
end

local function findNape(root)
	for _, d in ipairs(root:GetDescendants()) do
		if d:IsA("BasePart") and d.Name == "Nape" then
			return d
		end
	end
	return nil
end

local function applyNapeToRig(rig)
	if not (rig and rig:IsA("Model")) then return end
	local nape = findNape(rig)
	if not nape then return end

	storeBasePartState(nape)

	if State.NapeEnabled then
		nape.CanCollide = false
		nape.CanTouch = true
		nape.CanQuery = true
		nape.Massless = true
		nape.Anchored = false

		local ox = nape:GetAttribute("HB_OrigSizeX")
		local oy = nape:GetAttribute("HB_OrigSizeY")
		local oz = nape:GetAttribute("HB_OrigSizeZ")
		if ox and oy and oz then
			nape.Size = Vector3.new(ox, oy, oz) * State.NapeMult
		end
	else
		restoreBasePartState(nape)
	end
end

local function disableBasePart(part)
	if part.Name == "Nape" then return end
	storeBasePartState(part)
	part.CanTouch = false
	part.CanQuery = false
	part.CanCollide = false
	part.Massless = true
end

local function disableAny(inst)
	if inst:IsA("BasePart") then
		disableBasePart(inst)
		return
	end
	for _, d in ipairs(inst:GetDescendants()) do
		if d:IsA("BasePart") then
			disableBasePart(d)
		end
	end
end

local function applyDisableGrabHitboxesToRig(rig)
	if not (rig and rig:IsA("Model")) then return end

	if not State.DisableGrabHitboxes then
		for _, d in ipairs(rig:GetDescendants()) do
			if d:IsA("BasePart") and d.Name ~= "Nape" then
				restoreBasePartState(d)
			end
		end
		return
	end

	local collisionsFolder = rig:FindFirstChild("Collisions")
	if collisionsFolder then
		for _, d in ipairs(collisionsFolder:GetDescendants()) do
			if COLLISION_HITBOX_NAMES[d.Name] then
				disableAny(d)
			end
		end
	end

	for _, d in ipairs(rig:GetDescendants()) do
		if LIMB_NAMES[d.Name] then
			disableAny(d)
		end
	end

	local head = rig:FindFirstChild("Head", true)
	if head then
		for _, d in ipairs(head:GetDescendants()) do
			if EXTRA_COLLIDER_NAMES[d.Name] then
				disableAny(d)
			end
		end
	end
end

local function patchRig(rig)
	applyNapeToRig(rig)
	applyDisableGrabHitboxesToRig(rig)
end

local function patchAll()
	patchRig(TemplateRig)
	for _, rig in ipairs(TitansFolder:GetChildren()) do
		patchRig(rig)
	end
end

patchAll()

track(TitansFolder.ChildAdded:Connect(function(rig)
	task.wait(0.15)
	patchRig(rig)
	task.delay(0.75, function()
		patchRig(rig)
	end)
end))

local debugByNape = {}

local function getRoot()
	local char = player.Character
	if not char then return nil end
	return char:FindFirstChild("HumanoidRootPart")
end

local function getTitanType(rig)
	local attr = rig:GetAttribute("TitanType")
	if typeof(attr) == "string" and attr ~= "" then
		return attr
	end
	return rig.Name
end

local function makeBox(nape)
	local box = Instance.new("SelectionBox")
	box.Name = "TitanESP_Box"
	box.Adornee = nape
	box.LineThickness = 0.05
	box.Color3 = Color3.fromRGB(255, 0, 0)
	local t = math.clamp(State.TitanESPBoxTransparency, 0, 1)
	box.Transparency = t
	box.SurfaceTransparency = t
	box.Parent = nape
	return box
end

local function makeText(nape)
	local bb = Instance.new("BillboardGui")
	bb.Name = "TitanESP_Info"
	bb.Adornee = nape
	bb.AlwaysOnTop = true
	bb.Size = UDim2.fromOffset(220, 36)
	bb.StudsOffset = Vector3.new(0, 3.1, 0)

	local label = Instance.new("TextLabel")
	label.Name = "Info"
	label.Size = UDim2.fromScale(1, 1)
	label.BackgroundTransparency = 1
	label.TextColor3 = Color3.fromRGB(255, 255, 255)
	label.TextStrokeTransparency = 0.35
	label.Font = Enum.Font.GothamBold
	label.TextSize = 16
	label.TextXAlignment = Enum.TextXAlignment.Center
	label.TextYAlignment = Enum.TextYAlignment.Center
	label.Text = ""
	label.Parent = bb

	bb.Parent = nape
	return bb, label
end

local function espAttach(rig)
	if not rig:IsA("Model") then return end
	local nape = findNape(rig)
	if not nape then return end
	if debugByNape[nape] then return end

	local box = makeBox(nape)
	local bb, label = makeText(nape)
	debugByNape[nape] = { box = box, bb = bb, label = label, rig = rig }

	track(nape.AncestryChanged:Connect(function(_, parent)
		if parent == nil then
			local info = debugByNape[nape]
			if info then
				if info.box then info.box:Destroy() end
				if info.bb then info.bb:Destroy() end
			end
			debugByNape[nape] = nil
		end
	end))
end

local function espDetachAll()
	for nape, info in pairs(debugByNape) do
		if info.box then info.box:Destroy() end
		if info.bb then info.bb:Destroy() end
		debugByNape[nape] = nil
	end
end

local function espApplyTransparency()
	local t = math.clamp(State.TitanESPBoxTransparency, 0, 1)
	for _, info in pairs(debugByNape) do
		if info and info.box then
			info.box.Transparency = t
			info.box.SurfaceTransparency = t
		end
	end
end

for _, rig in ipairs(TitansFolder:GetChildren()) do
	if State.TitanESP then
		espAttach(rig)
	end
end

track(TitansFolder.ChildAdded:Connect(function(rig)
	task.wait(0.15)
	if State.TitanESP then
		espAttach(rig)
	end
	task.delay(0.75, function()
		if State.TitanESP then
			espAttach(rig)
		end
	end)
end))

track(RunService.RenderStepped:Connect(function()
	if not State.TitanESP then return end
	local hrp = getRoot()
	if not hrp then return end
	for nape, info in pairs(debugByNape) do
		if not (nape and nape.Parent and info and info.label and info.rig) then
			debugByNape[nape] = nil
		else
			local dist = (hrp.Position - nape.Position).Magnitude
			local ttype = getTitanType(info.rig)
			info.label.Text = string.format("%s  |  %.1f studs", ttype, dist)
		end
	end
end))

local SafeFall = {}
do
	local MIN_DOWNWARD_SPEED = 55
	local COOLDOWN = 0.8
	local POST_RELEASE_GRACE = 0.35
	local HOVER_HEIGHT = 3
	local RAY_DISTANCE = 1500
	local ALIGN_MAX_FORCE = 90000
	local ALIGN_RESPONSIVENESS = 35

	local lastTrigger = 0
	local ignoreUntil = 0

	local sfConns = {}
	local function sfDisconnect()
		for _, c in ipairs(sfConns) do
			pcall(function() c:Disconnect() end)
		end
		table.clear(sfConns)
	end

	local function sfTrack(conn)
		table.insert(sfConns, conn)
		return conn
	end

	local function getJumpHeightStuds(humanoid)
		local g = Workspace.Gravity
		if humanoid.UseJumpPower == false then
			local jh = humanoid.JumpHeight
			if jh and jh > 0 then
				return jh
			end
		end
		local jp = humanoid.JumpPower or 50
		return (jp * jp) / (2 * g)
	end

	local function raycastDown(character, origin)
		local params = RaycastParams.new()
		params.FilterType = Enum.RaycastFilterType.Exclude
		params.FilterDescendantsInstances = { character }
		params.IgnoreWater = true
		return Workspace:Raycast(origin, Vector3.new(0, -RAY_DISTANCE, 0), params)
	end

	local function cleanupSoftLand(root)
		local ap = root:FindFirstChild("__SafeFallAlignPosition")
		if ap then ap:Destroy() end
		local att = root:FindFirstChild("__SafeFallAttachment")
		if att then att:Destroy() end
	end

	local function softLand(character, humanoid, root)
		if tick() < ignoreUntil then return end
		if (tick() - lastTrigger) < COOLDOWN then return end
		lastTrigger = tick()

		local hit = raycastDown(character, root.Position)
		if not hit then return end

		cleanupSoftLand(root)

		local att = Instance.new("Attachment")
		att.Name = "__SafeFallAttachment"
		att.Parent = root

		local ap = Instance.new("AlignPosition")
		ap.Name = "__SafeFallAlignPosition"
		ap.Mode = Enum.PositionAlignmentMode.OneAttachment
		ap.Attachment0 = att
		ap.MaxForce = ALIGN_MAX_FORCE
		ap.Responsiveness = ALIGN_RESPONSIVENESS
		ap.RigidityEnabled = false
		ap.Parent = root

		local v = root.AssemblyLinearVelocity
		root.AssemblyLinearVelocity = Vector3.new(v.X, math.max(v.Y, -20), v.Z)

		humanoid:ChangeState(Enum.HumanoidStateType.Physics)

		local start = tick()
		local maxTime = 1.25

		local conn
		conn = RunService.Heartbeat:Connect(function()
			if not character.Parent or humanoid.Health <= 0 then
				if conn then conn:Disconnect() end
				cleanupSoftLand(root)
				return
			end

			if (tick() - start) > maxTime then
				if conn then conn:Disconnect() end
				cleanupSoftLand(root)
				ignoreUntil = tick() + POST_RELEASE_GRACE
				return
			end

			local h = raycastDown(character, root.Position)
			if not h then
				if conn then conn:Disconnect() end
				cleanupSoftLand(root)
				ignoreUntil = tick() + POST_RELEASE_GRACE
				return
			end

			local targetY = h.Position.Y + HOVER_HEIGHT
			ap.Position = Vector3.new(root.Position.X, targetY, root.Position.Z)

			local distToFloor = root.Position.Y - h.Position.Y
			if distToFloor <= (HOVER_HEIGHT + 0.6) then
				if conn then conn:Disconnect() end
				cleanupSoftLand(root)
				humanoid:ChangeState(Enum.HumanoidStateType.Running)
				ignoreUntil = tick() + POST_RELEASE_GRACE
				return
			end
		end)
	end

	local function setup(character)
		sfDisconnect()

		local humanoid = character:WaitForChild("Humanoid", 10)
		local root = character:WaitForChild("HumanoidRootPart", 10)
		if not humanoid or not root then return end

		local falling = false
		local fallStart = 0
		local peakY = 0
		local armed = false

		local function resetFall()
			falling = false
			armed = false
			fallStart = 0
			peakY = 0
		end

		sfTrack(humanoid.StateChanged:Connect(function(_, newState)
			if newState == Enum.HumanoidStateType.Freefall then
				if not falling then
					falling = true
					armed = false
					fallStart = tick()
					peakY = root.Position.Y
				end
			elseif newState == Enum.HumanoidStateType.Landed or newState == Enum.HumanoidStateType.Running then
				resetFall()
				cleanupSoftLand(root)
				ignoreUntil = tick() + 0.15
			end
		end))

		sfTrack(RunService.Heartbeat:Connect(function()
			if not character.Parent or humanoid.Health <= 0 then
				resetFall()
				return
			end

			if not State.SafeFallEnabled then
				if falling then
					resetFall()
					cleanupSoftLand(root)
				end
				return
			end

			if tick() < ignoreUntil then return end
			if not falling then return end

			local y = root.Position.Y
			if y > peakY then peakY = y end

			local v = root.AssemblyLinearVelocity
			if v.Y > -MIN_DOWNWARD_SPEED then
				return
			end

			local fallDist = peakY - y
			if fallDist <= getJumpHeightStuds(humanoid) then
				return
			end

			local minTime = math.clamp(State.MinFallTime, 0, 1)
			if not armed and (tick() - fallStart) >= minTime then
				armed = true
			end
			if not armed then return end

			local hit = raycastDown(character, root.Position)
			if not hit then return end

			local near = math.clamp(State.NearGroundDist, 8, 25)
			local distToFloor = root.Position.Y - hit.Position.Y
			if distToFloor > near then
				return
			end

			softLand(character, humanoid, root)
		end))

		sfTrack(humanoid.Died:Connect(function()
			resetFall()
			if root and root.Parent then
				cleanupSoftLand(root)
			end
		end))
	end

	SafeFall.Setup = setup
	SafeFall.Disconnect = sfDisconnect
end

track(player.CharacterAdded:Connect(function(char)
	if unloaded then return end
	SafeFall.Setup(char)
end))
if player.Character then
	SafeFall.Setup(player.Character)
end

local function mk(t, props)
	local inst = Instance.new(t)
	for k, v in pairs(props or {}) do
		inst[k] = v
	end
	return inst
end

local COL_BG = Color3.fromRGB(16,16,16)
local COL_PANEL = Color3.fromRGB(22,22,22)
local COL_PANEL2 = Color3.fromRGB(28,28,28)
local COL_STROKE = Color3.fromRGB(55,55,55)
local COL_TEXT = Color3.fromRGB(235,235,235)
local COL_SUB = Color3.fromRGB(160,160,160)
local COL_PURP = Color3.fromRGB(140, 90, 255)
local COL_OFF = Color3.fromRGB(120, 55, 55)
local COL_ON = Color3.fromRGB(60, 160, 90)

local gui = mk("ScreenGui", {
	Name = "CheddarcheeseHub",
	ResetOnSpawn = false,
	Parent = player:WaitForChild("PlayerGui"),
})

local main = mk("Frame", {
	Parent = gui,
	Position = UDim2.new(0.15, 0, 0.2, 0),
	Size = UDim2.new(0, 700, 0, 380),
	BackgroundColor3 = COL_BG,
	BorderSizePixel = 0,
})
mk("UICorner", { Parent = main, CornerRadius = UDim.new(0, 8) })
mk("UIStroke", { Parent = main, Color = COL_STROKE, Thickness = 1, Transparency = 0.35 })

local topBar = mk("Frame", {
	Parent = main,
	Size = UDim2.new(1, 0, 0, 34),
	BackgroundColor3 = COL_BG,
	BorderSizePixel = 0,
})
mk("UIStroke", { Parent = topBar, Color = COL_STROKE, Thickness = 1, Transparency = 0.5 })

mk("TextLabel", {
	Parent = topBar,
	Position = UDim2.new(0, 12, 0, 0),
	Size = UDim2.new(1, -260, 1, 0),
	BackgroundTransparency = 1,
	Font = Enum.Font.GothamBold,
	TextSize = 14,
	TextXAlignment = Enum.TextXAlignment.Left,
	TextColor3 = COL_TEXT,
	Text = "Cheddarcheese Hub",
})

mk("TextLabel", {
	Parent = topBar,
	AnchorPoint = Vector2.new(1, 0.5),
	Position = UDim2.new(1, -110, 0.5, 0),
	Size = UDim2.new(0, 200, 1, 0),
	BackgroundTransparency = 1,
	Font = Enum.Font.Gotham,
	TextSize = 11,
	TextXAlignment = Enum.TextXAlignment.Right,
	TextColor3 = COL_SUB,
	Text = "RightShift to toggle UI",
})

local closeBtn = mk("TextButton", {
	Parent = topBar,
	AnchorPoint = Vector2.new(1, 0.5),
	Position = UDim2.new(1, -40, 0.5, 0),
	Size = UDim2.new(0, 26, 0, 22),
	BackgroundColor3 = Color3.fromRGB(120, 55, 55),
	TextColor3 = COL_TEXT,
	BorderSizePixel = 0,
	Font = Enum.Font.GothamBold,
	TextSize = 14,
	Text = "X",
	AutoButtonColor = false,
})
mk("UICorner", { Parent = closeBtn, CornerRadius = UDim.new(0, 6) })
mk("UIStroke", { Parent = closeBtn, Color = COL_STROKE, Thickness = 1, Transparency = 0.4 })

local minimizeBtn = mk("TextButton", {
	Parent = topBar,
	AnchorPoint = Vector2.new(1, 0.5),
	Position = UDim2.new(1, -10, 0.5, 0),
	Size = UDim2.new(0, 26, 0, 22),
	BackgroundColor3 = COL_PANEL,
	TextColor3 = COL_TEXT,
	BorderSizePixel = 0,
	Font = Enum.Font.GothamBold,
	TextSize = 14,
	Text = "–",
	AutoButtonColor = false,
})
mk("UICorner", { Parent = minimizeBtn, CornerRadius = UDim.new(0, 6) })
mk("UIStroke", { Parent = minimizeBtn, Color = COL_STROKE, Thickness = 1, Transparency = 0.4 })

local side = mk("Frame", {
	Parent = main,
	Position = UDim2.new(0, 0, 0, 34),
	Size = UDim2.new(0, 160, 1, -34),
	BackgroundColor3 = COL_PANEL,
	BorderSizePixel = 0,
})
mk("UIStroke", { Parent = side, Color = COL_STROKE, Thickness = 1, Transparency = 0.55 })

local content = mk("Frame", {
	Parent = main,
	Position = UDim2.new(0, 160, 0, 34),
	Size = UDim2.new(1, -160, 1, -34),
	BackgroundColor3 = COL_BG,
	BorderSizePixel = 0,
})

local pages = {}
local function newPage(name)
	local f = mk("Frame", {
		Parent = content,
		Size = UDim2.new(1, 0, 1, 0),
		BackgroundTransparency = 1,
		Visible = false,
	})
	pages[name] = f
	return f
end

local pageMain = newPage("Main")
local pageVisuals = newPage("Visuals")
local pageMisc = newPage("Misc")
local pageUI = newPage("UI Settings")

local function sectionBox(parent, x, y, w, h, headerText)
	local box = mk("Frame", {
		Parent = parent,
		Position = UDim2.new(0, x, 0, y),
		Size = UDim2.new(0, w, 0, h),
		BackgroundColor3 = COL_PANEL,
		BorderSizePixel = 0,
	})
	mk("UICorner", { Parent = box, CornerRadius = UDim.new(0, 10) })
	mk("UIStroke", { Parent = box, Color = COL_STROKE, Thickness = 1, Transparency = 0.5 })

	mk("TextLabel", {
		Parent = box,
		Position = UDim2.new(0, 12, 0, 10),
		Size = UDim2.new(1, -24, 0, 18),
		BackgroundTransparency = 1,
		Font = Enum.Font.GothamBold,
		TextSize = 13,
		TextXAlignment = Enum.TextXAlignment.Left,
		TextColor3 = COL_TEXT,
		Text = headerText,
	})

	return box
end

local function toggleRow(parent, y, labelText)
	mk("TextLabel", {
		Parent = parent,
		Position = UDim2.new(0, 12, 0, y),
		Size = UDim2.new(1, -120, 0, 20),
		BackgroundTransparency = 1,
		Font = Enum.Font.Gotham,
		TextSize = 12,
		TextXAlignment = Enum.TextXAlignment.Left,
		TextColor3 = COL_SUB,
		Text = labelText,
	})

	local btn = mk("TextButton", {
		Parent = parent,
		AnchorPoint = Vector2.new(1, 0),
		Position = UDim2.new(1, -12, 0, y-2),
		Size = UDim2.new(0, 52, 0, 22),
		BackgroundColor3 = COL_ON,
		TextColor3 = COL_TEXT,
		BorderSizePixel = 0,
		Font = Enum.Font.GothamBold,
		TextSize = 12,
		Text = "ON",
		AutoButtonColor = false,
	})
	mk("UICorner", { Parent = btn, CornerRadius = UDim.new(0, 10) })
	mk("UIStroke", { Parent = btn, Color = COL_STROKE, Thickness = 1, Transparency = 0.5 })

	return btn
end

local function setToggle(btn, on)
	btn.Text = on and "ON" or "OFF"
	btn.BackgroundColor3 = on and COL_ON or COL_OFF
end

local boxA = sectionBox(pageMain, 16, 16, 420, 320, "Titan Settings")
local napeToggle = toggleRow(boxA, 44, "Nape Hitbox")
local grabHBtoggle = toggleRow(boxA, 78, "Disable Grab Hitboxes")

mk("TextLabel", {
	Parent = boxA,
	Position = UDim2.new(0, 12, 0, 120),
	Size = UDim2.new(1, -24, 0, 18),
	BackgroundTransparency = 1,
	Font = Enum.Font.Gotham,
	TextSize = 12,
	TextXAlignment = Enum.TextXAlignment.Left,
	TextColor3 = COL_SUB,
	Text = "Nape Multiplier (1-30)",
})

local multBox = mk("TextBox", {
	Parent = boxA,
	Position = UDim2.new(0, 12, 0, 142),
	Size = UDim2.new(0, 280, 0, 26),
	BackgroundColor3 = Color3.fromRGB(26,26,26),
	TextColor3 = COL_TEXT,
	BorderSizePixel = 0,
	ClearTextOnFocus = false,
	Font = Enum.Font.GothamSemibold,
	TextSize = 12,
	Text = tostring(State.NapeMult),
})
mk("UICorner", { Parent = multBox, CornerRadius = UDim.new(0, 8) })
mk("UIStroke", { Parent = multBox, Color = COL_STROKE, Thickness = 1, Transparency = 0.55 })

local applyBtn = mk("TextButton", {
	Parent = boxA,
	Position = UDim2.new(0, 302, 0, 142),
	Size = UDim2.new(0, 106, 0, 26),
	BackgroundColor3 = COL_PURP,
	TextColor3 = COL_TEXT,
	BorderSizePixel = 0,
	Font = Enum.Font.GothamBold,
	TextSize = 12,
	Text = "APPLY",
	AutoButtonColor = false,
})
mk("UICorner", { Parent = applyBtn, CornerRadius = UDim.new(0, 8) })

local boxV = sectionBox(pageVisuals, 16, 16, 420, 320, "Visuals")
local espToggle = toggleRow(boxV, 44, "Titan ESP (Nape)")

mk("TextLabel", {
	Parent = boxV,
	Position = UDim2.new(0, 12, 0, 88),
	Size = UDim2.new(1, -24, 0, 18),
	BackgroundTransparency = 1,
	Font = Enum.Font.Gotham,
	TextSize = 12,
	TextXAlignment = Enum.TextXAlignment.Left,
	TextColor3 = COL_SUB,
	Text = "ESP Box Transparency (0-1)",
})

local espTransBox = mk("TextBox", {
	Parent = boxV,
	Position = UDim2.new(0, 12, 0, 110),
	Size = UDim2.new(0, 280, 0, 26),
	BackgroundColor3 = Color3.fromRGB(26,26,26),
	TextColor3 = COL_TEXT,
	BorderSizePixel = 0,
	ClearTextOnFocus = false,
	Font = Enum.Font.GothamSemibold,
	TextSize = 12,
	Text = tostring(State.TitanESPBoxTransparency),
})
mk("UICorner", { Parent = espTransBox, CornerRadius = UDim.new(0, 8) })
mk("UIStroke", { Parent = espTransBox, Color = COL_STROKE, Thickness = 1, Transparency = 0.55 })

local espApplyBtn = mk("TextButton", {
	Parent = boxV,
	Position = UDim2.new(0, 302, 0, 110),
	Size = UDim2.new(0, 106, 0, 26),
	BackgroundColor3 = COL_PURP,
	TextColor3 = COL_TEXT,
	BorderSizePixel = 0,
	Font = Enum.Font.GothamBold,
	TextSize = 12,
	Text = "APPLY",
	AutoButtonColor = false,
})
mk("UICorner", { Parent = espApplyBtn, CornerRadius = UDim.new(0, 8) })

local boxF = sectionBox(pageMisc, 16, 16, 420, 320, "Misc")

local safeFallToggle = toggleRow(boxF, 44, "Safe Fall (Soft Land)")

local bindBtn = mk("TextButton", {
	Parent = boxF,
	Position = UDim2.new(0, 12, 0, 76),
	Size = UDim2.new(0, 180, 0, 24),
	BackgroundColor3 = Color3.fromRGB(26,26,26),
	TextColor3 = COL_TEXT,
	BorderSizePixel = 0,
	Font = Enum.Font.GothamBold,
	TextSize = 12,
	Text = "Keybind: L (Click to set)",
	AutoButtonColor = false,
})
mk("UICorner", { Parent = bindBtn, CornerRadius = UDim.new(0, 8) })
mk("UIStroke", { Parent = bindBtn, Color = COL_STROKE, Thickness = 1, Transparency = 0.55 })

mk("TextLabel", {
	Parent = boxF,
	Position = UDim2.new(0, 12, 0, 110),
	Size = UDim2.new(1, -24, 0, 18),
	BackgroundTransparency = 1,
	Font = Enum.Font.Gotham,
	TextSize = 12,
	TextXAlignment = Enum.TextXAlignment.Left,
	TextColor3 = COL_SUB,
	Text = "Minimum Fall Time (0-1)",
})

local minFallBox = mk("TextBox", {
	Parent = boxF,
	Position = UDim2.new(0, 12, 0, 132),
	Size = UDim2.new(0, 280, 0, 26),
	BackgroundColor3 = Color3.fromRGB(26,26,26),
	TextColor3 = COL_TEXT,
	BorderSizePixel = 0,
	ClearTextOnFocus = false,
	Font = Enum.Font.GothamSemibold,
	TextSize = 12,
	Text = tostring(State.MinFallTime),
})
mk("UICorner", { Parent = minFallBox, CornerRadius = UDim.new(0, 8) })
mk("UIStroke", { Parent = minFallBox, Color = COL_STROKE, Thickness = 1, Transparency = 0.55 })

local minFallApply = mk("TextButton", {
	Parent = boxF,
	Position = UDim2.new(0, 302, 0, 132),
	Size = UDim2.new(0, 106, 0, 26),
	BackgroundColor3 = COL_PURP,
	TextColor3 = COL_TEXT,
	BorderSizePixel = 0,
	Font = Enum.Font.GothamBold,
	TextSize = 12,
	Text = "APPLY",
	AutoButtonColor = false,
})
mk("UICorner", { Parent = minFallApply, CornerRadius = UDim.new(0, 8) })

mk("TextLabel", {
	Parent = boxF,
	Position = UDim2.new(0, 12, 0, 172),
	Size = UDim2.new(1, -24, 0, 18),
	BackgroundTransparency = 1,
	Font = Enum.Font.Gotham,
	TextSize = 12,
	TextXAlignment = Enum.TextXAlignment.Left,
	TextColor3 = COL_SUB,
	Text = "Near Ground Distance (8-25)",
})

local nearGroundBox = mk("TextBox", {
	Parent = boxF,
	Position = UDim2.new(0, 12, 0, 194),
	Size = UDim2.new(0, 280, 0, 26),
	BackgroundColor3 = Color3.fromRGB(26,26,26),
	TextColor3 = COL_TEXT,
	BorderSizePixel = 0,
	ClearTextOnFocus = false,
	Font = Enum.Font.GothamSemibold,
	TextSize = 12,
	Text = tostring(State.NearGroundDist),
})
mk("UICorner", { Parent = nearGroundBox, CornerRadius = UDim.new(0, 8) })
mk("UIStroke", { Parent = nearGroundBox, Color = COL_STROKE, Thickness = 1, Transparency = 0.55 })

local nearGroundApply = mk("TextButton", {
	Parent = boxF,
	Position = UDim2.new(0, 302, 0, 194),
	Size = UDim2.new(0, 106, 0, 26),
	BackgroundColor3 = COL_PURP,
	TextColor3 = COL_TEXT,
	BorderSizePixel = 0,
	Font = Enum.Font.GothamBold,
	TextSize = 12,
	Text = "APPLY",
	AutoButtonColor = false,
})
mk("UICorner", { Parent = nearGroundApply, CornerRadius = UDim.new(0, 8) })

local boxU = sectionBox(pageUI, 16, 16, 420, 320, "UI Settings")
mk("TextLabel", {
	Parent = boxU,
	Position = UDim2.new(0, 12, 0, 44),
	Size = UDim2.new(1, -24, 0, 18),
	BackgroundTransparency = 1,
	Font = Enum.Font.Gotham,
	TextSize = 12,
	TextXAlignment = Enum.TextXAlignment.Left,
	TextColor3 = COL_SUB,
	Text = "Toggle Keybind: RightShift",
})

local resetPos = mk("TextButton", {
	Parent = boxU,
	Position = UDim2.new(0, 12, 0, 74),
	Size = UDim2.new(0, 180, 0, 26),
	BackgroundColor3 = COL_PURP,
	TextColor3 = COL_TEXT,
	BorderSizePixel = 0,
	Font = Enum.Font.GothamBold,
	TextSize = 12,
	Text = "Reset UI Position",
	AutoButtonColor = false,
})
mk("UICorner", { Parent = resetPos, CornerRadius = UDim.new(0, 8) })
mk("UIStroke", { Parent = resetPos, Color = COL_STROKE, Thickness = 1, Transparency = 0.55 })

local unloadBtn = mk("TextButton", {
	Parent = boxU,
	Position = UDim2.new(0, 12, 0, 110),
	Size = UDim2.new(0, 180, 0, 26),
	BackgroundColor3 = Color3.fromRGB(120, 55, 55),
	TextColor3 = COL_TEXT,
	BorderSizePixel = 0,
	Font = Enum.Font.GothamBold,
	TextSize = 12,
	Text = "Unload Hub",
	AutoButtonColor = false,
})
mk("UICorner", { Parent = unloadBtn, CornerRadius = UDim.new(0, 8) })
mk("UIStroke", { Parent = unloadBtn, Color = COL_STROKE, Thickness = 1, Transparency = 0.55 })

local tabButtons = {}

local function setTabActive(name)
	for tabName, frame in pairs(pages) do
		frame.Visible = (tabName == name)
	end
	for tabName, btn in pairs(tabButtons) do
		local on = (tabName == name)
		btn.BackgroundColor3 = on and COL_PANEL2 or COL_PANEL
		btn.TextColor3 = on and COL_TEXT or COL_SUB
	end
end

local function makeSideTab(y, text, name)
	local tab = mk("TextButton", {
		Parent = side,
		Position = UDim2.new(0, 10, 0, y),
		Size = UDim2.new(1, -20, 0, 36),
		BackgroundColor3 = COL_PANEL,
		TextColor3 = COL_SUB,
		BorderSizePixel = 0,
		Font = Enum.Font.GothamSemibold,
		TextSize = 13,
		TextXAlignment = Enum.TextXAlignment.Left,
		Text = "   "..text,
		AutoButtonColor = false,
	})
	mk("UICorner", { Parent = tab, CornerRadius = UDim.new(0, 10) })
	tabButtons[name] = tab
	track(tab.MouseButton1Click:Connect(function()
		setTabActive(name)
	end))
	return tab
end

makeSideTab(12, "Main", "Main")
makeSideTab(56, "Visuals", "Visuals")
makeSideTab(100, "Misc", "Misc")
makeSideTab(144, "UI Settings", "UI Settings")

local bindingSafeFall = false

local function keyName(kc)
	local s = tostring(kc)
	local p = s:match("^Enum%.KeyCode%.(.+)$")
	return p or s
end

local function refreshBindText()
	bindBtn.Text = "Keybind: " .. keyName(State.SafeFallKey) .. (bindingSafeFall and " (Press a key...)" or " (Click to set)")
end

local function applyMultiplier()
	local n = tonumber(multBox.Text)
	if not n then
		multBox.Text = tostring(State.NapeMult)
		return
	end
	n = math.floor(n + 0.5)
	n = math.clamp(n, 1, 30)
	State.NapeMult = n
	patchAll()
end

local function applyESPTrans()
	local n = tonumber(espTransBox.Text)
	if not n then
		espTransBox.Text = tostring(State.TitanESPBoxTransparency)
		return
	end
	n = math.clamp(n, 0, 1)
	State.TitanESPBoxTransparency = n
	espTransBox.Text = tostring(State.TitanESPBoxTransparency)
	espApplyTransparency()
end

local function applyMinFall()
	local n = tonumber(minFallBox.Text)
	if not n then
		minFallBox.Text = tostring(State.MinFallTime)
		return
	end
	n = math.clamp(n, 0, 1)
	State.MinFallTime = n
	minFallBox.Text = tostring(State.MinFallTime)
end

local function applyNearGround()
	local n = tonumber(nearGroundBox.Text)
	if not n then
		nearGroundBox.Text = tostring(State.NearGroundDist)
		return
	end
	n = math.floor(n + 0.5)
	n = math.clamp(n, 8, 25)
	State.NearGroundDist = n
	nearGroundBox.Text = tostring(State.NearGroundDist)
end

local function refresh()
	setToggle(napeToggle, State.NapeEnabled)
	setToggle(grabHBtoggle, State.DisableGrabHitboxes)
	setToggle(espToggle, State.TitanESP)
	setToggle(safeFallToggle, State.SafeFallEnabled)
	multBox.Text = tostring(State.NapeMult)
	espTransBox.Text = tostring(State.TitanESPBoxTransparency)
	minFallBox.Text = tostring(State.MinFallTime)
	nearGroundBox.Text = tostring(State.NearGroundDist)
	refreshBindText()
	if not State.TitanESP then
		espDetachAll()
	end
end

local function unload()
	if unloaded then return end
	unloaded = true
	State.TitanESP = false
	State.SafeFallEnabled = false
	espDetachAll()
	SafeFall.Disconnect()
	safeDisconnectAll()
	if gui then
		gui:Destroy()
	end
end

track(closeBtn.MouseButton1Click:Connect(function()
	unload()
end))

track(unloadBtn.MouseButton1Click:Connect(function()
	unload()
end))

track(napeToggle.MouseButton1Click:Connect(function()
	if unloaded then return end
	State.NapeEnabled = not State.NapeEnabled
	patchAll()
	refresh()
end))

track(grabHBtoggle.MouseButton1Click:Connect(function()
	if unloaded then return end
	State.DisableGrabHitboxes = not State.DisableGrabHitboxes
	patchAll()
	refresh()
end))

track(espToggle.MouseButton1Click:Connect(function()
	if unloaded then return end
	State.TitanESP = not State.TitanESP
	if State.TitanESP then
		for _, rig in ipairs(TitansFolder:GetChildren()) do
			espAttach(rig)
		end
		espApplyTransparency()
	else
		espDetachAll()
	end
	refresh()
end))

track(safeFallToggle.MouseButton1Click:Connect(function()
	if unloaded then return end
	State.SafeFallEnabled = not State.SafeFallEnabled
	refresh()
end))

track(bindBtn.MouseButton1Click:Connect(function()
	if unloaded then return end
	bindingSafeFall = not bindingSafeFall
	refreshBindText()
end))

track(applyBtn.MouseButton1Click:Connect(function()
	if unloaded then return end
	applyMultiplier()
	refresh()
end))

track(multBox.FocusLost:Connect(function()
	if unloaded then return end
	applyMultiplier()
	refresh()
end))

track(espApplyBtn.MouseButton1Click:Connect(function()
	if unloaded then return end
	applyESPTrans()
	refresh()
end))

track(espTransBox.FocusLost:Connect(function()
	if unloaded then return end
	applyESPTrans()
	refresh()
end))

track(minFallApply.MouseButton1Click:Connect(function()
	if unloaded then return end
	applyMinFall()
	refresh()
end))

track(minFallBox.FocusLost:Connect(function()
	if unloaded then return end
	applyMinFall()
	refresh()
end))

track(nearGroundApply.MouseButton1Click:Connect(function()
	if unloaded then return end
	applyNearGround()
	refresh()
end))

track(nearGroundBox.FocusLost:Connect(function()
	if unloaded then return end
	applyNearGround()
	refresh()
end))

track(resetPos.MouseButton1Click:Connect(function()
	if unloaded then return end
	main.Position = UDim2.new(0.15, 0, 0.2, 0)
end))

do
	local dragging = false
	local dragStart, startPos

	track(topBar.InputBegan:Connect(function(input)
		if unloaded then return end
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = true
			dragStart = input.Position
			startPos = main.Position
		end
	end))

	track(UserInputService.InputChanged:Connect(function(input)
		if unloaded then return end
		if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
			local delta = input.Position - dragStart
			main.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
		end
	end))

	track(UserInputService.InputEnded:Connect(function(input)
		if unloaded then return end
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			dragging = false
		end
	end))
end

local minimized = false
local fullSize = main.Size

track(minimizeBtn.MouseButton1Click:Connect(function()
	if unloaded then return end
	minimized = not minimized
	content.Visible = not minimized
	side.Visible = not minimized
	main.Size = minimized and UDim2.new(fullSize.X.Scale, fullSize.X.Offset, 0, 34) or fullSize
	minimizeBtn.Text = minimized and "+" or "–"
end))

track(UserInputService.InputBegan:Connect(function(input, gp)
	if unloaded then return end
	if gp then return end
	if UserInputService:GetFocusedTextBox() then return end

	if bindingSafeFall then
		if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode ~= Enum.KeyCode.Unknown then
			State.SafeFallKey = input.KeyCode
			bindingSafeFall = false
			refresh()
		end
		return
	end

	if input.KeyCode == Enum.KeyCode.RightShift then
		gui.Enabled = not gui.Enabled
		return
	end

	if input.KeyCode == State.SafeFallKey then
		State.SafeFallEnabled = not State.SafeFallEnabled
		refresh()
		return
	end
end))

setTabActive("Main")
refresh()
